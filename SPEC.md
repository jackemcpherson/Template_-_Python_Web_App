# **A Production-Ready Copier Template for Modern Python Web Applications**

## **An Opinionated Architecture for Modern Python Applications**

### **Introduction and Philosophy**

This report details the complete file structure and content for a production-ready Copier template designed to scaffold modern, containerized Python web applications. The architecture is founded on a set of core, opinionated principles: radical performance, uncompromising code quality, superior developer experience (DX), and security as a default posture. This is not a template that offers endless choices; rather, it is a feature-rich starting point that codifies a suite of best practices to enforce consistency, reduce decision fatigue, and accelerate development velocity for high-performing engineering teams. By providing a robust, pre-configured foundation, it allows developers to focus immediately on business logic rather than on the recurring complexities of project setup, tooling integration, and CI/CD automation.

### **Core Technology Choices and Rationale**

The technology stack has been meticulously selected to align with the template's core philosophy, prioritizing modern, high-performance tools that represent the current state-of-the-art in the Python ecosystem.

#### **FastAPI & FastHTML**

The template employs a hybrid architecture that leverages both FastAPI and FastHTML, utilizing each framework for its specific strengths. FastAPI serves as the high-performance engine for building robust, type-validated JSON APIs, a domain where it excels.1 FastHTML is integrated to handle server-rendered HTML content. This approach drastically simplifies the frontend development process by enabling the creation of interactive user interfaces using only Python, thereby eliminating the need for a separate JavaScript framework, a complex build pipeline, and the associated cognitive overhead.2 This combination provides the performance and rigorous validation of FastAPI for machine-to-machine communication while offering the simplicity and rapid development cycle of FastHTML for human-facing interfaces, all within a unified Python codebase.1

#### **uv as the Unified Toolchain**

The template exclusively uses uv for all package and virtual environment management tasks. This decision moves beyond simply replacing pip and virtualenv; it embraces uv as a holistic project management tool. Written in Rust, uv provides a 10-100x performance increase over its predecessors, which dramatically shortens feedback loops during local development and significantly reduces CI/CD execution times.4 Its integrated command set simplifies the entire development workflow, from project initialization (  
uv init) and dependency installation (uv pip sync) to script execution (uv run), providing a single, consistent, and blazing-fast interface for all environment-related tasks.6

#### **The "Rustification" Trend**

The strategic selection of both uv and ruff is a deliberate architectural decision that aligns the template with a significant and powerful trend in the Python ecosystem: the adoption of high-performance, Rust-based tooling. Historically, the performance of Python-based development tools like pip, flake8, and isort has been a notable bottleneck, leading to slow dependency resolution, long CI runs, and sluggish local linting. The introduction of Rust-based alternatives provides an order-of-magnitude performance improvement.4 This shift signifies a maturation of the ecosystem, where the community is embracing solutions from outside the confines of pure Python to solve long-standing challenges in developer productivity. This template embodies that modern philosophy, ensuring that projects built from it are not only efficient by design but also positioned at the forefront of the industry's technical evolution.

### **Complete Project File Structure**

The following file tree represents the complete structure of the project that will be generated by the Copier template. This structure provides a logical and clean separation of concerns, from application source code to CI/CD workflows and project configuration.  
{{ project\_name }}/  
├──.dockerignore  
├──.github/  
│ └── workflows/  
│ └── ci.yml  
├── Dockerfile  
├── Makefile  
├── README.md  
├── copier.yml  
├── pyproject.toml  
├── src/  
│ └── {{ project\_name | lower | replace(' ', '\_') }}/  
│ ├── init.py  
│ └── main.py  
└── tests/  
├── init.py  
└── test\_main.py  
---

## **The Application Core: FastAPI and FastHTML Integration**

### **Structuring the Application (src/ layout)**

The template enforces a src layout, where all application source code resides within the src/ directory. This is a modern Python packaging best practice that provides a clean separation between the application's importable code and the project's root-level configuration files (e.g., pyproject.toml, Makefile). This structure prevents common import-related issues and ensures that the package must be properly installed to be tested, mirroring how it will behave in a production environment.

### **The Main Application Module (src/{{ project\_name | lower | replace(' ', '\_') }}/main.py)**

This file serves as the main entry point for the web application. It initializes the FastAPI application and defines a simple "Hello World" route using FastHTML to demonstrate the core integration pattern.

#### **Full File Content**

Python

\# src/{{ project\_name | lower | replace(' ', '\_') }}/main.py  
"""  
Main application module for the {{ project\_name }} service.

This module initializes the FastAPI application and defines the primary routes.  
"""

from fasthtml.common import \*

\# Initialize the FastHTML application, which provides both the FastAPI app instance  
\# and the route decorator.  
app, rt \= fast\_app()

@rt("/")  
def get() \-\> HTML:  
    """  
    Serves the main index page of the application.

    This route returns a simple "Hello World" message rendered as an HTML page  
    using FastHTML components.

    Returns:  
        A Titled component containing the page's title and body.  
    """  
    return Titled(  
        "{{ project\_name }}",  \# Sets the \<title\> tag of the HTML page.  
        Div(  \# A container div for the page content.  
            H1("Welcome to {{ project\_name }}\!"),  
            P("This is a modern web application scaffolded with FastAPI and FastHTML."),  
            P("Powered by uv, ruff, and other great tools."),  
            id="main-content",  
        ),  
    )

\# The serve() function is part of the FastHTML library and is used to run  
\# the application with uvicorn. It's typically called when the script is  
\# executed directly. For this template, we rely on the \`make run-dev\` command  
\# which calls uvicorn directly, so a \_\_main\_\_ block is not strictly necessary  
\# but is good practice.  
if \_\_name\_\_ \== "\_\_main\_\_":  
    serve()

#### **Analysis**

The main.py module demonstrates the elegant simplicity of the FastHTML framework.

* **Initialization:** The line app, rt \= fast\_app() creates both a standard FastAPI application instance (app) and a routing decorator (rt).1  
* **Routing:** The @rt("/") decorator registers the get function to handle requests for the root URL. Following FastHTML best practices, the function name itself defines the route when no path is provided to the decorator, and special names like index or get map to /.3  
* **Pythonic HTML:** The function returns a hierarchy of Python objects (Titled, Div, H1, P) from fasthtml.common. These objects directly map to HTML elements, allowing for type-safe, component-based UI construction entirely within Python, eliminating the need for a separate templating language like Jinja2.2  
* **Self-Contained:** The entire "Hello World" application is defined in a single, readable file, showcasing FastHTML's focus on minimizing boilerplate and unifying the client/server stack.2

### **Initial Test Suite (tests/test\_main.py)**

To ensure the template is fully functional and to provide a foundation for Test-Driven Development (TDD), a basic test case is included. This test verifies that the main endpoint is reachable and returns a successful HTTP response.

#### **Full File Content**

Python

\# tests/test\_main.py  
"""  
Test suite for the main application module.

This file contains tests for the primary routes of the web application.  
"""

import httpx  
from fastapi.testclient import TestClient

from {{ project\_name | lower | replace(' ', '\_') }}.main import app

client \= TestClient(app)

def test\_read\_main() \-\> None:  
    """  
    Test that the main endpoint returns a successful response.

    Verifies that a GET request to the root URL ("/") returns an HTTP 200 OK  
    status code and that the response content includes the expected title.  
    """  
    response \= client.get("/")  
    assert response.status\_code \== 200  
    assert "\<title\>{{ project\_name }}\</title\>" in response.text  
    assert "\<h1\>Welcome to {{ project\_name }}\!\</h1\>" in response.text

#### **Analysis**

This test file establishes a standard testing pattern for a FastAPI application.

* **TestClient:** FastAPI's TestClient is used to make requests to the application in-memory, without needing to run a live server. It is built on top of httpx, providing a familiar and powerful interface for testing APIs.  
* **Basic Verification:** The test\_read\_main function performs a simple but crucial check: it sends a GET request to the root path (/) and asserts that the HTTP status code is 200 (OK). It also checks for the presence of key HTML elements in the response body, confirming that the FastHTML components were rendered correctly.

---

## **Unified Project and Dependency Management with uv**

The pyproject.toml file is the cornerstone of modern Python project management. This template centralizes all project metadata, dependencies, and tool configurations within this single file, creating a canonical source of truth that is compliant with PEP 621\.

### **The Central Configuration Hub (pyproject.toml \- Project Definition)**

The \[project\] table defines the core metadata for the package, such as its name, version, and authors. This information is used by build tools and package indexes like PyPI.

#### **Full File Content (Partial \- \[project\] section)**

Ini, TOML

\# pyproject.toml

\[project\]  
name \= "{{ project\_name | lower | replace(' ', '\_') }}"  
version \= "{{ initial\_version }}"  
description \= "{{ project\_description }}"  
authors \= \[  
    { name \= "{{ author\_name }}", email \= "{{ author\_email }}" },  
\]  
readme \= "README.md"  
requires-python \= "\>=3.12"  
license \= { text \= "MIT" }  
classifiers \=

\[project.urls\]  
Homepage \= "https://github.com/your-username/{{ project\_name | lower | replace(' ', '-') }}"  
Repository \= "https://github.com/your-username/{{ project\_name | lower | replace(' ', '-') }}"

#### **Analysis**

This section is populated dynamically by Copier using the values provided by the user during project generation. The use of Jinja2 templating ({{... }}) ensures that the generated project is immediately customized with the correct metadata.9 The  
requires-python key specifies the minimum Python version, and the classifiers help package indexes categorize the project correctly.

### **Dependency Specification**

Dependencies are managed declaratively within pyproject.toml, separating core application requirements from those needed only for development, testing, and quality assurance. This approach ensures that production environments remain lean and secure.

#### **Full File Content (Partial \- \[project.dependencies\] and \[project.optional-dependencies\])**

Ini, TOML

\# pyproject.toml (continued)

\[project.dependencies\]  
\# Core application dependencies  
fastapi \= "^0.111.0"  
python-fasthtml \= "^0.0.21"  
uvicorn \= { version \= "^0.30.1", extras \= \["standard"\] }

\[project.optional-dependencies\]  
\# Development and testing dependencies  
dev \= \[  
    "ruff",  
    "mypy",  
    "pytest",  
    "pytest-cov",  
    "bandit",  
    "httpx", \# For API testing  
\]

#### **Analysis**

* **Core Dependencies:** The \[project.dependencies\] table lists the packages required for the application to run in any environment, including production.  
* **Optional Dependencies:** The \[project.optional-dependencies\] table defines groups of dependencies for specific purposes. The dev group contains all the tools needed for linting, type checking, security scanning, and testing.11 This separation is critical. The CI/CD pipeline and local development environments will install this group using a command like  
  uv pip sync pyproject.toml \--all-extras, while a production deployment will only install the core dependencies, minimizing the attack surface and container image size. This workflow completely obviates the need for separate requirements.txt files, as pyproject.toml becomes the single source for all dependency information.4

---

## **A Single Source of Truth for Code Quality and Security**

A hallmark of a mature and maintainable software project is the consistent and automated enforcement of quality standards. By centralizing the configuration for all quality assurance tools within pyproject.toml, the project becomes a self-contained and self-documenting artifact. A developer or a CI system only needs to read this one file to understand the project's standards for formatting, linting, type safety, and security. This architectural pattern decouples the *definition* of quality from its *execution*. The CI workflow becomes a simple orchestrator that invokes commands like uv run lint, while the project itself, through pyproject.toml, dictates the precise rules for that command. This makes the project more portable, reduces configuration drift, and dramatically simplifies the CI pipeline.8

### **Linting and Formatting (\[tool.ruff\])**

Ruff is an extremely fast, Rust-based linter and formatter that can replace a multitude of older Python tools. This template configures it to be strict, enforcing a high standard of code quality and a consistent style across the entire codebase.

#### **Full File Content (Partial)**

Ini, TOML

\# pyproject.toml (continued)

\[tool.ruff\]  
\# Set the minimum Python version to target.  
target-version \= "py312"  
line-length \= 88  
\# Exclude commonly ignored directories.  
extend-exclude \= \["docs/"\]

\[tool.ruff.lint\]  
\# Enable all rules (\`ALL\`) and then explicitly ignore a few.  
\# This is a "strict by default" approach.  
select \= \["ALL"\]  
ignore \=

\# Configure pydocstyle to enforce Google-style docstrings.  
\[tool.ruff.lint.pydocstyle\]  
convention \= "google"

\[tool.ruff.format\]  
\# Use double quotes for strings.  
quote-style \= "double"  
\# Like Black, respect magic trailing commas.  
skip-magic-trailing-comma \= false

#### **Analysis**

This configuration establishes a rigorous and opinionated standard for code quality.

* **Strict by Default:** The select \= \["ALL"\] directive enables every rule available in Ruff.15 This is a deliberate choice to maximize the tool's effectiveness. Rather than incrementally adding rules, this approach ensures the highest level of scrutiny from the outset. The  
  ignore list is then used to selectively disable a small number of rules that are often considered overly pedantic for many projects (e.g., requiring docstrings in every \_\_init\_\_.py).  
* **Google-Style Docstrings:** The \[tool.ruff.lint.pydocstyle\] table with convention \= "google" directly satisfies the non-negotiable user requirement to enforce this specific docstring format.16 This ensures that all documentation within the code is consistent and machine-readable.  
* **Unified Tooling:** This single configuration section replaces what would have previously been separate files and configurations for flake8, isort, pydocstyle, and black, demonstrating Ruff's power as an all-in-one quality tool.8

### **Static Type Analysis (\[tool.mypy\])**

Mypy is the de facto standard for static type checking in Python. A strict Mypy configuration is essential for catching type-related errors before runtime, improving code reliability, and making large codebases more maintainable.

#### **Full File Content (Partial)**

Ini, TOML

\# pyproject.toml (continued)

\[tool.mypy\]  
\# Enable strict mode and all optional checks.  
strict \= true

\# Additional strictness flags for professional-grade type safety.  
disallow\_untyped\_defs \= true  
disallow\_any\_unimported \= true  
no\_implicit\_optional \= true  
check\_untyped\_defs \= true  
warn\_return\_any \= true  
warn\_unused\_ignores \= true

\# Improve error messages.  
show\_error\_codes \= true

\# Specify the source path.  
mypy\_path \= "src"  
packages \= \["{{ project\_name | lower | replace(' ', '\_') }}"\]

\# Exclude test files from some of the strictest checks if needed,  
\# though for a new project, it's best to type-check tests as well.  
\# \[\[tool.mypy.overrides\]\]  
\# module \= "tests.\*"  
\# allow\_untyped\_defs \= true

#### **Analysis**

This configuration is based on established best practices for professional-grade projects and directly implements a "strict" mode.18

* **strict \= true:** This flag is a convenient shortcut that enables a wide range of strictness checks by default.  
* **Enforcing Full Typing:** Flags like disallow\_untyped\_defs \= true and check\_untyped\_defs \= true are the most critical. They mandate that all function signatures are fully annotated and that Mypy will inspect the bodies of these functions, leaving no part of the codebase unchecked.18  
* **Preventing Any Creep:** warn\_return\_any \= true and disallow\_any\_unimported \= true help prevent the Any type from silently propagating through the codebase, which would undermine the entire purpose of static type checking.18  
* **Code Maintainability:** warn\_unused\_ignores \= true ensures that \# type: ignore comments are removed once they are no longer necessary, preventing code rot.18

### **Automated Security Scanning (\[tool.bandit\])**

Bandit is a tool designed to find common security issues in Python code. Integrating its configuration into pyproject.toml ensures that security scanning is a consistent and automated part of the development lifecycle.

#### **Full File Content (Partial)**

Ini, TOML

\# pyproject.toml (continued)

\[tool.bandit\]  
\# Recursively scan the source directory.  
targets \= \["src"\]  
\# Exclude the tests directory to avoid flagging test-specific code (e.g., asserts).  
exclude\_dirs \= \["tests"\]  
\# Only report on issues with medium or high confidence and severity.  
level \= "MEDIUM"  
confidence \= "MEDIUM"

#### **Analysis**

This configuration is targeted and pragmatic.

* **Scoped Scanning:** By setting targets \= \["src"\] and exclude\_dirs \= \["tests"\], the scan is focused exclusively on the production application code, reducing noise from false positives that might arise from test fixtures or mock objects.14  
* **Thresholding:** The level and confidence settings are configured to MEDIUM, which strikes a balance between catching significant potential vulnerabilities and avoiding an overwhelming number of low-confidence warnings. This makes the security report more actionable for developers.

### **Testing and Coverage (\[tool.pytest.ini\_options\])**

Pytest is the standard for testing in the Python community. This configuration integrates it with pytest-cov to not only run tests but also measure how much of the application code is exercised by them.

#### **Full File Content (Partial)**

Ini, TOML

\# pyproject.toml (continued)

\[tool.pytest.ini\_options\]  
\# Automatically discover tests in the "tests" directory.  
testpaths \= \["tests"\]  
\# Add command-line options for pytest.  
addopts \=

#### **Analysis**

This configuration automates and standardizes the testing process.

* **testpaths:** This tells pytest where to look for tests, making the test execution command simpler.  
* **addopts:** This is the key to integration. It automatically appends command-line arguments every time pytest is run.13  
  * \--cov=src/...: This instructs pytest-cov to measure code coverage specifically for the application package within the src directory.19  
  * \--cov-report=...: These options configure the coverage report, providing both an immediate summary in the terminal (term-missing) and a comprehensive html report that can be explored for a detailed analysis of untested code paths.

---

## **Secure and Efficient Containerization with a Multi-Stage Dockerfile**

The containerization strategy is a critical component of a production-ready application. It directly impacts deployment speed, resource consumption, and security. The choice to use uv is not just a development convenience; it is a performance enabler for the container build process. The dramatic speed increase in dependency installation significantly reduces the time spent in what is often the slowest stage of a Python Docker build. This allows for a more efficient and better-structured build process that maximizes Docker's layer caching capabilities, resulting in faster builds and smaller final images.20

### **The Multi-Stage Dockerfile**

This Dockerfile uses a multi-stage build pattern to create a minimal, secure, and efficient production image. The build process is separated into distinct stages, ensuring that the final image contains only the essential artifacts needed to run the application.

#### **Full File Content**

Dockerfile

\# Dockerfile

\# \---- Builder Stage \----  
\# This stage is responsible for installing dependencies. It contains build tools  
\# and the full Python installation, which are not needed in the final image.  
FROM python:3.12-slim-bullseye AS builder

\# Set environment variables for Python and uv.  
ENV PYTHONDONTWRITEBYTECODE=1  
ENV PYTHONUNBUFFERED=1  
ENV UV\_VENV\_PATH=/opt/venv

\# Install uv, the fast Python package installer.  
RUN pip install uv

\# Create a virtual environment in a standard location.  
RUN uv venv $UV\_VENV\_PATH

\# Activate the virtual environment for subsequent commands.  
ENV PATH="$UV\_VENV\_PATH/bin:$PATH"

\# Copy only the dependency definition file first. This allows Docker to cache  
\# the dependency layer. This layer will only be rebuilt if pyproject.toml changes.  
WORKDIR /app  
COPY pyproject.toml.

\# Install all dependencies, including the 'dev' group for a consistent environment,  
\# though for a pure production build, '--no-dev' could be used.  
\# The \--system-site-packages flag is not used, ensuring a fully isolated venv.  
RUN uv pip sync pyproject.toml \--all-extras

\# \---- Final Stage \----  
\# This stage builds the final, minimal production image.  
FROM python:3.12-slim-bullseye AS final

\# Set environment variables.  
ENV PYTHONDONTWRITEBYTECODE=1  
ENV PYTHONUNBUFFERED=1

\# Create a non-root user and group for security.  
\# Running containers as a non-root user is a critical security best practice.  
RUN addgroup \--system \--gid 1001 appgroup && \\  
    adduser \--system \--uid 1001 \--gid 1001 appuser

\# Copy the virtual environment with all its dependencies from the builder stage.  
COPY \--from=builder /opt/venv /opt/venv

\# Copy the application source code into the image.  
WORKDIR /app  
COPY \--chown=appuser:appgroup src/./src/

\# Activate the virtual environment.  
ENV PATH="/opt/venv/bin:$PATH"

\# Switch to the non-root user.  
USER appuser

\# Expose the port the application will run on.  
EXPOSE 8000

\# Define the command to run the application using uvicorn.  
\# It listens on all interfaces (0.0.0.0) so it's accessible from outside the container.  
CMD \["uvicorn", "{{ project\_name | lower | replace(' ', '\_') }}.main:app", "--host", "0.0.0.0", "--port", "8000"\]

#### **Analysis**

This Dockerfile implements several modern best practices for containerization.22

* **Multi-Stage Build:** The use of two stages, builder and final, is crucial. The builder stage contains uv and potentially other build-time tools. The final stage copies *only* the installed dependencies (the virtual environment) and the application source code. This ensures the final image is as small as possible and has a reduced attack surface because it contains no build tools.21  
* **Dependency Layer Caching:** By copying pyproject.toml and running uv pip sync *before* copying the application source code, Docker's layer caching is maximized. The dependency layer, which changes infrequently, will be cached and reused across builds, making subsequent builds that only involve source code changes significantly faster.  
* **Security:** The application is run as a non-root user (appuser). This is a fundamental security measure that mitigates the potential impact of a container breakout vulnerability.  
* **Minimal Base Image:** The use of python:3.12-slim-bullseye as the base image provides a good balance of a small image size while still including the necessary system libraries for many common Python packages.

### **The .dockerignore File**

The .dockerignore file is analogous to .gitignore. It specifies files and directories that should be excluded from the build context sent to the Docker daemon. This is important for build speed and security.

#### **Full File Content**

\#.dockerignore

\# Git files  
.git  
.gitignore

\# Docker files  
.dockerignore  
Dockerfile

\# Python virtual environment  
.venv  
venv

\# Python cache files  
\_\_pycache\_\_  
\*.pyc

\# Tool-specific cache and report directories  
.mypy\_cache  
.pytest\_cache  
.ruff\_cache  
htmlcov/

#### **Analysis**

Excluding these files serves two main purposes. First, it prevents potentially large or sensitive directories (like .git or a local .venv) from being sent to the Docker daemon, which speeds up the docker build command. Second, it ensures that local artifacts and caches (like \_\_pycache\_\_ or .pytest\_cache) are not accidentally copied into the final image, keeping it clean and reproducible.26  
---

## **Reusable Continuous Integration with GitHub Actions**

A robust CI/CD pipeline is essential for modern software development. This template provides a single, reusable GitHub Actions workflow that automates all quality and security checks. The design of this workflow is intentionally generic, relying on the centralized pyproject.toml for all tool configurations. This makes the workflow highly portable and maintainable.

### **The Workflow File (.github/workflows/ci.yml)**

This file defines the "Lint and Test" workflow, which is triggered on pushes to the main branch, on all pull requests, and can also be run manually.

#### **Full File Content**

YAML

\#.github/workflows/ci.yml

name: Lint and Test

on:  
  push:  
    branches: \[ "main" \]  
  pull\_request:  
  workflow\_dispatch:

jobs:  
  lint-and-test:  
    runs-on: ubuntu-latest  
    strategy:  
      matrix:  
        python-version: \["3.12"\]

    steps:  
      \- name: Checkout repository  
        uses: actions/checkout@v4

      \- name: Set up Python ${{ matrix.python-version }}  
        uses: actions/setup-python@v5  
        with:  
          python-version: ${{ matrix.python-version }}

      \- name: Install uv  
        uses: astral-sh/setup-uv@v1  
        with:  
          \# Pin to a specific uv version for reproducible builds  
          version: "0.2.15"

      \- name: Install dependencies  
        run: uv pip sync pyproject.toml \--all-extras

      \- name: Check formatting with ruff  
        run: uv run ruff format \--check.

      \- name: Lint with ruff  
        run: uv run ruff check.

      \- name: Type check with mypy  
        run: uv run mypy

      \- name: Scan for security vulnerabilities with bandit  
        run: uv run bandit

      \- name: Run tests with pytest  
        run: uv run pytest

#### **Analysis**

This workflow exemplifies modern CI best practices.

* **Triggers:** The on block configures the workflow to run automatically on the most important events: pushes to the main branch (ensuring main is always stable) and on every pull request (providing feedback to contributors before merging).27 The  
  workflow\_dispatch trigger allows for manual runs, which is useful for debugging or re-running checks.  
* **Setup:** The initial steps are standard for a Python project: checking out the code, setting up the desired Python version, and installing uv using the official astral-sh/setup-uv action.28  
* **Dependency Installation:** The uv pip sync command installs all dependencies defined in pyproject.toml, including the dev group specified in \--all-extras. This ensures the CI environment precisely matches the development environment.  
* **Reusability Principle:** The most critical aspect of this workflow is how the quality checks are executed. Each step uses uv run \<tool\>. There are no tool-specific flags, paths, or configurations hardcoded in the YAML file. ruff knows to read \[tool.ruff\], mypy reads \[tool.mypy\], and so on. This means the workflow is completely decoupled from the project's specific rules. The rules can be updated in pyproject.toml without ever touching the CI configuration, making this workflow exceptionally reusable and easy to maintain.30

---

## **Dynamic Project Scaffolding with Copier**

Copier is a modern project templating tool that uses Jinja2 for templating and a simple YAML file for configuration. It enables the creation of dynamic templates that prompt the user for project-specific information and then render a complete, customized project structure.

### **The Template Configuration (copier.yml)**

This file is the heart of the Copier template. It defines the questions that will be asked to the user when they generate a new project from this template.

#### **Full File Content**

YAML

\# copier.yml

\# Define the questions to ask the user when generating the project.  
project\_name:  
  type: str  
  help: What is the name of your project?  
  default: "My Awesome App"

project\_description:  
  type: str  
  help: Provide a short description of the project.  
  default: "A modern web application built with FastAPI and FastHTML."

author\_name:  
  type: str  
  help: What is your full name?

author\_email:  
  type: str  
  help: What is your email address?

initial\_version:  
  type: str  
  help: What is the initial version of the project?  
  default: "0.1.0"

#### **Analysis**

This configuration file is straightforward and user-friendly.

* **User Prompts:** For each key (project\_name, project\_description, etc.), Copier will present a prompt to the user.  
* **type and help:** The type key ensures basic validation (e.g., the value is a string), and the help text provides context to the user, guiding them to provide the correct information.9  
* **default:** Providing a default value for certain prompts (like initial\_version) speeds up the generation process for common cases, improving the developer experience. The user can simply accept the default by pressing Enter.

### **Templating in Action**

The values collected from the user via copier.yml are made available as variables within the template's files. Copier processes any file that does not have a .jinja suffix but contains Jinja2 syntax.

#### **Example from README.md**

The README.md file is a prime example of how these variables are used to create a customized and professional-looking project overview from the moment of creation.

##### **Full File Content**

# **{{ project\_name }}**

{{ project\_description }}

## **Overview**

This project is a modern, production-ready web application scaffolded from an opinionated Copier template. It uses a high-performance technology stack designed for developer productivity and robust performance.

* **Backend Framework:** [FastAPI](https://fastapi.tiangolo.com/)  
* **Frontend Rendering:**([https://www.fastht.ml/](https://www.fastht.ml/))  
* **Package Management:** [uv](https://github.com/astral-sh/uv)  
* **Code Quality:** ruff, mypy, bandit  
* **Testing:** pytest with coverage  
* **Containerization:** Multi-stage Dockerfile  
* **CI/CD:** GitHub Actions

## **Developer Experience**

This project includes a Makefile to streamline common development tasks. See the table below for a list of available commands.

| Command | Description |
| :---- | :---- |
| make install | Creates a virtual environment and installs all project dependencies. |
| make lint | Formats the code and runs the linter using ruff. |
| make test | Executes the test suite with pytest and generates a coverage report. |
| make security | Scans the codebase for security vulnerabilities using bandit. |
| make check-all | Sequentially runs the lint, test, and security checks. |
| make run-dev | Starts the FastAPI development server with live reloading. |
| make docker-build | Builds the production Docker image for the application. |
| make docker-run | Runs the application inside a Docker container. |

## **Getting Started**

1. \*\*Install Dependencies:\*\*bash  
   make install

2. **Run the Development Server:**  
   Bash  
   make run-dev

   The application will be available at http://127.0.0.1:8000.  
3. **Run Quality Checks:**  
   Bash  
   make check-all

\#\#\#\# Analysis

The \`README.md\` file uses \`{{ project\_name }}\` and \`{{ project\_description }}\` at the top to immediately brand the generated documentation. This simple act of templating transforms a generic file into a project-specific artifact, providing a polished and professional entry point for new developers joining the project.

\---

\#\# Streamlining the Developer Workflow with a Makefile

While modern tools like \`uv\` have powerful command-line interfaces, remembering the specific commands and arguments for various tasks can be a source of friction. A \`Makefile\` serves as a simple, universal entry point for common development operations. It provides short, memorable commands that encapsulate the underlying tooling calls, creating a consistent and user-friendly developer experience.

\#\#\# The \`Makefile\`

This \`Makefile\` provides a set of targets for all essential development tasks, from initial setup to running tests and building Docker images.

\#\#\#\# Full File Content

\`\`\`makefile  
\# Makefile

\# Use.PHONY to ensure these targets run even if files with the same name exist.  
.PHONY: install lint test security check-all run-dev docker-build docker-run

\# Default command to show help.  
help:  
	@echo "Available commands:"  
	@echo "  install       \- Set up the development environment and install dependencies"  
	@echo "  lint          \- Run ruff for formatting and linting"  
	@echo "  test          \- Run pytest with coverage"  
	@echo "  security      \- Run bandit for security scanning"  
	@echo "  check-all     \- Run all checks (lint, test, security)"  
	@echo "  run-dev       \- Start the development server with hot-reloading"  
	@echo "  docker-build  \- Build the production Docker image"  
	@echo "  docker-run    \- Run the application in a Docker container"

\# Target to set up the virtual environment and install dependencies using uv.  
install:  
	@echo "\>\>\> Creating virtual environment with uv..."  
	uv venv  
	@echo "\>\>\> Installing dependencies with uv..."  
	uv pip sync pyproject.toml \--all-extras  
	@echo "✅ Environment is ready."

\# Target to run the linter and formatter.  
lint:  
	@echo "\>\>\> Running ruff formatter and linter..."  
	uv run ruff format.  
	uv run ruff check.  
	@echo "✅ Linting complete."

\# Target to run the test suite with coverage.  
test:  
	@echo "\>\>\> Running tests with pytest and coverage..."  
	uv run pytest  
	@echo "✅ Testing complete. See htmlcov/ for detailed report."

\# Target to run the security scanner.  
security:  
	@echo "\>\>\> Running bandit security scanner..."  
	uv run bandit  
	@echo "✅ Security scan complete."

\# Target to run all quality checks sequentially.  
check-all: lint test security

\# Target to run the FastAPI development server.  
run-dev:  
	@echo "\>\>\> Starting development server at http://127.0.0.1:8000..."  
	uv run uvicorn {{ project\_name | lower | replace(' ', '\_') }}.main:app \--host 127.0.0.1 \--port 8000 \--reload

\# Target to build the Docker image.  
docker-build:  
	@echo "\>\>\> Building Docker image..."  
	docker build \-t {{ project\_name | lower | replace(' ', '-') }}:latest.  
	@echo "✅ Docker image built."

\# Target to run the application using the Docker image.  
docker-run:  
	@echo "\>\>\> Running application in Docker container..."  
	docker run \-p 8000:8000 \--rm {{ project\_name | lower | replace(' ', '-') }}:latest

#### **Analysis**

Each target in the Makefile is a simple wrapper around a more complex command, providing significant value to the developer.

* **Abstraction:** Commands like make install abstract away the details of uv venv and uv pip sync. A developer doesn't need to remember the exact uv command; they just need to know the high-level action they want to perform.  
* **Consistency:** The Makefile provides a consistent interface for tasks across all projects that use this template. This standardization is invaluable for teams, as it reduces the learning curve when switching between projects.  
* **Discoverability:** A developer can simply read the Makefile (or run make help) to discover all the common tasks available for the project.  
* **Reliance on pyproject.toml:** Just like the CI workflow, the Makefile targets for lint, test, and security are simple uv run commands. They rely entirely on the centralized configuration in pyproject.toml, reinforcing the single-source-of-truth principle.

### **Developer Experience Quick-Start Guide**

To facilitate rapid onboarding, the README.md includes a summary of the Makefile commands. This table acts as a quick-reference guide, allowing a developer to become productive with the project in minutes. It abstracts the underlying tooling and presents a simple, verb-based interface for all essential development activities. This focus on a streamlined and intuitive workflow is a key component of a high-quality developer experience.

| Command | Description |
| :---- | :---- |
| make install | Creates a virtual environment and installs all project dependencies using uv. |
| make lint | Formats the code and runs the linter using ruff. |
| make test | Executes the test suite with pytest and generates a coverage report. |
| make security | Scans the codebase for security vulnerabilities using bandit. |
| make check-all | Sequentially runs the lint, test, and security checks. |
| make run-dev | Starts the FastAPI development server with live reloading. |
| make docker-build | Builds the production Docker image for the application. |
| make docker-run | Runs the application inside a Docker container. |

---

## **Conclusion and Next Steps**

### **Summary of Features**

This Copier template provides a comprehensive, opinionated, and production-ready foundation for modern Python web applications. It synthesizes a suite of best practices and state-of-the-art tools into a cohesive and efficient starting point. Key features include:

* **High-Performance Stack:** A hybrid FastAPI and FastHTML architecture for robust APIs and simple, Python-native UIs.  
* **Blazing-Fast Tooling:** Exclusive use of uv and ruff for superior performance in dependency management, linting, and formatting.  
* **Unified Configuration:** A single pyproject.toml file serves as the canonical source of truth for all project metadata, dependencies, and tool configurations.  
* **Rigorous Quality Gates:** Pre-configured, strict settings for ruff, mypy, bandit, and pytest ensure that code quality, type safety, and security are enforced automatically.  
* **Optimized Containerization:** A secure, multi-stage Dockerfile that produces minimal and efficient production images.  
* **Reusable CI/CD:** A generic and maintainable GitHub Actions workflow that automates all quality checks.  
* **Superior Developer Experience:** A streamlined workflow powered by a simple Makefile, enabling rapid onboarding and consistent development practices.

### **Guidance for Use**

To generate a new project from this template, a user must have uv installed. The project can then be scaffolded with a single command:

Bash

uvx copier copy gh:your-username/your-template-repo-name path/to/local-project

After generation, the user should navigate into the new project directory and follow the quick-start guide provided in the README.md:

1. **cd path/to/local-project**  
2. **make install**  
3. **make run-dev**

This template is designed to be a robust starting point. From here, developers can immediately begin building out their application's features, confident that the underlying foundation is performant, secure, and maintainable.

#### **Works cited**

1. Take inspiration from FastHTML to make implementing HTMX easier · fastapi fastapi · Discussion \#11966 \- GitHub, accessed on September 20, 2025, [https://github.com/fastapi/fastapi/discussions/11966](https://github.com/fastapi/fastapi/discussions/11966)  
2. Python FastHTML: A Beginner's Guide with Examples \- DataCamp, accessed on September 20, 2025, [https://www.datacamp.com/tutorial/python-fasthtml](https://www.datacamp.com/tutorial/python-fasthtml)  
3. FastHTML Best Practices – fasthtml, accessed on September 20, 2025, [https://www.fastht.ml/docs/ref/best\_practice.html](https://www.fastht.ml/docs/ref/best_practice.html)  
4. UV The Lightning-Fast Python Package Manager \- Python Cheatsheet, accessed on September 20, 2025, [https://www.pythoncheatsheet.org/blog/python-uv-package-manager](https://www.pythoncheatsheet.org/blog/python-uv-package-manager)  
5. Python UV: The Ultimate Guide to the Fastest Python Package Manager \- DataCamp, accessed on September 20, 2025, [https://www.datacamp.com/tutorial/python-uv](https://www.datacamp.com/tutorial/python-uv)  
6. uv \- Astral Docs, accessed on September 20, 2025, [https://docs.astral.sh/uv/](https://docs.astral.sh/uv/)  
7. Working on projects | uv \- Astral Docs, accessed on September 20, 2025, [https://docs.astral.sh/uv/guides/projects/](https://docs.astral.sh/uv/guides/projects/)  
8. ruff · PyPI, accessed on September 20, 2025, [https://pypi.org/project/ruff/0.0.228/](https://pypi.org/project/ruff/0.0.228/)  
9. copier \- The Blue Book, accessed on September 20, 2025, [https://lyz-code.github.io/blue-book/copier/](https://lyz-code.github.io/blue-book/copier/)  
10. Configuring a template \- copier, accessed on September 20, 2025, [https://copier.readthedocs.io/en/v5.1.0/configuring/](https://copier.readthedocs.io/en/v5.1.0/configuring/)  
11. Move from pip-tools to uv to lock Python dependencies | by Théomé Borck | Medium, accessed on September 20, 2025, [https://medium.com/@theomeb/move-from-pip-tools-to-uv-to-lock-python-dependencies-48c5aade1453](https://medium.com/@theomeb/move-from-pip-tools-to-uv-to-lock-python-dependencies-48c5aade1453)  
12. The mypy configuration file \- mypy 1.18.2 documentation, accessed on September 20, 2025, [https://mypy.readthedocs.io/en/stable/config\_file.html](https://mypy.readthedocs.io/en/stable/config_file.html)  
13. Configuration \- pytest documentation, accessed on September 20, 2025, [https://docs.pytest.org/en/stable/reference/customize.html](https://docs.pytest.org/en/stable/reference/customize.html)  
14. Configuration — Bandit documentation, accessed on September 20, 2025, [https://bandit.readthedocs.io/en/latest/config.html](https://bandit.readthedocs.io/en/latest/config.html)  
15. python \- Why does Ruff not show as many diagnostics as I expect? \- Stack Overflow, accessed on September 20, 2025, [https://stackoverflow.com/questions/77852109/why-does-ruff-not-show-as-many-diagnostics-as-i-expect](https://stackoverflow.com/questions/77852109/why-does-ruff-not-show-as-many-diagnostics-as-i-expect)  
16. Settings | Ruff \- Astral Docs, accessed on September 20, 2025, [https://docs.astral.sh/ruff/settings/](https://docs.astral.sh/ruff/settings/)  
17. ruff · PyPI, accessed on September 20, 2025, [https://pypi.org/project/ruff/0.0.240/](https://pypi.org/project/ruff/0.0.240/)  
18. Professional-grade mypy configuration | Wolt Careers, accessed on September 20, 2025, [https://careers.wolt.com/en/blog/tech/professional-grade-mypy-configuration](https://careers.wolt.com/en/blog/tech/professional-grade-mypy-configuration)  
19. Configuration \- pytest-cov 7.0.0 documentation \- Read the Docs, accessed on September 20, 2025, [https://pytest-cov.readthedocs.io/en/latest/config.html](https://pytest-cov.readthedocs.io/en/latest/config.html)  
20. Multi-Stage Docker Builds for Python Projects using uv \- DEV Community, accessed on September 20, 2025, [https://dev.to/kummerer94/multi-stage-docker-builds-for-pyton-projects-using-uv-223g](https://dev.to/kummerer94/multi-stage-docker-builds-for-pyton-projects-using-uv-223g)  
21. Deep Dive into uv Dockerfiles by Astral: Image Size, Performance & Best Practices \- Medium, accessed on September 20, 2025, [https://medium.com/@benitomartin/deep-dive-into-uv-dockerfiles-by-astral-image-size-performance-best-practices-5790974b9579](https://medium.com/@benitomartin/deep-dive-into-uv-dockerfiles-by-astral-image-size-performance-best-practices-5790974b9579)  
22. Multi-stage Dockerfile with Python and \`uv\` \- GitHub Gist, accessed on September 20, 2025, [https://gist.github.com/adamghill/419d02e95b1563ad76b0c36995e829b8](https://gist.github.com/adamghill/419d02e95b1563ad76b0c36995e829b8)  
23. Multi-stage builds \- Docker Docs, accessed on September 20, 2025, [https://docs.docker.com/build/building/multi-stage/](https://docs.docker.com/build/building/multi-stage/)  
24. Multi-stage builds \- Docker Docs, accessed on September 20, 2025, [https://docs.docker.com/get-started/docker-concepts/building-images/multi-stage-builds/](https://docs.docker.com/get-started/docker-concepts/building-images/multi-stage-builds/)  
25. Best practice Dockerfile for Python with uv | Container Builds \- Depot.dev, accessed on September 20, 2025, [https://depot.dev/docs/container-builds/how-to-guides/optimal-dockerfiles/python-uv-dockerfile](https://depot.dev/docs/container-builds/how-to-guides/optimal-dockerfiles/python-uv-dockerfile)  
26. An example of using uv in Docker images \- GitHub, accessed on September 20, 2025, [https://github.com/astral-sh/uv-docker-example](https://github.com/astral-sh/uv-docker-example)  
27. Building and testing Python \- GitHub Docs, accessed on September 20, 2025, [https://docs.github.com/actions/guides/building-and-testing-python](https://docs.github.com/actions/guides/building-and-testing-python)  
28. astral-sh/setup-uv: Set up your GitHub Actions workflow ... \- GitHub, accessed on September 20, 2025, [https://github.com/astral-sh/setup-uv](https://github.com/astral-sh/setup-uv)  
29. Using uv in GitHub Actions \- Astral Docs, accessed on September 20, 2025, [https://docs.astral.sh/uv/guides/integration/github/](https://docs.astral.sh/uv/guides/integration/github/)  
30. Most common Python linter, formatter? \- Reddit, accessed on September 20, 2025, [https://www.reddit.com/r/Python/comments/1i4t28v/most\_common\_python\_linter\_formatter/](https://www.reddit.com/r/Python/comments/1i4t28v/most_common_python_linter_formatter/)  
31. Python boilerplate using uv, pre-commit, prettier, pytest, GitHub Actions, mypy, ruff, bandit & docformatter., accessed on September 20, 2025, [https://github.com/smarlhens/python-boilerplate](https://github.com/smarlhens/python-boilerplate)